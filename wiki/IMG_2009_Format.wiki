#summary Description of the new Image format
#labels Documentation

= Introduction =

I created a special image format to achieve better lossless compression on the Imperium Galactica files than a PNG or PCX type compression would.

The idea is simple: try different encoding and compression method and keep the best one:

  * Palette or without palette: replace colors with index, and use a common palette. The palette should contain only the colors for the used indexes, not the entire possible colors.
  * compute effective bit per pixel ratio (e.g 1 BPP, 12 BPP) and store the indexed images on bits
  * for <9 BPP, try keeping the index size on 8BPP to allow a further compression to better capture patterns
  * try storing the image az raw 24bit (normal or transparent) or 32bit (= alpha channel) as  for small images, the palette might take up too much space in respect to the image data
  * try keeping it uncompressed (=no compression format overhead), GZIP-ped or ZIPped (maximum compression)

The preliminary results show, that recompressing 2089 PNG images results:

Uncompressed total image size: 149,639,816 bytes<br>
PNG compressed (mixed 8BPP and 32BPP): 13,724,378 bytes (9.17%)<br>
IMG_2009 compressed: 10,361,145 bytes(6.92%, 75.49% relative to the PNG)

However, the format itself is rather slower to compress and decompress, as the IO operation is bit sized. It is possible to speed it up when everything is 8, 16, 24 or 32 BPP.

= Format specification =

The first whole byte (as a character) is an indicator for compression:

|| *Value* || *Description* ||
|| 'R' || The image is in raw format - no compression ||
|| 'G' || The image is GZIP compressed ||
|| 'Z' || The image is ZIP compressed. The ZIP contains only a raw.img file entry. ||

The following bytes need to be interpreted according to this (e.g. start reading the file as a compressed stream)

The bit operations use least significant to most significant order, e.g. bit 0 of the input goes to bit 0 of the output byte. For multibyte data, this is equivalent to the little endian format.

|| *Bit Offset* || *Description* ||
|| 0 || Transparency indicator ||
|| 1 || Alpha channel indicator: the image contains not only transparency, but more alpha values than 0 or 0xFF. If this bit is set ||
|| 2 || The image contains palette ||
|| 3 - 7 || BPP: The bits per pixel - 1 (+ end of first byte) ||
|| 8 - 19 || W: The image width ||
|| 20 - 31 || H: The image height (+ end of 4th byte) ||

Based on the indicators, the following bytes can be different

== No palette is used ==
=== Transparent but no other alpha ==
If the image is transparent, but has no other alpha values, the following 24 bits contain the RGB color, that is used to indicate a transparent pixel.

After that, W x H number of 24 bits of RGB color bytes are stored as the pixels.

=== No transparency ==
If the alpha bit is zero, then W x Hnumber of 24 bits of RGB colors follow. If the alpha bit is one, then W x H number of 32 bits of ARGB colors follow.

== Palette is used ==
Remark: if the image has transparency and no other alpha, then the transparent index is the number of palette entries plus one and is never stored in the palette.

The following BPP bits contain the number of palette entries (PE) - 1.

If the image has more alpha, the following PE number of 32 bit entries contains the ARGB color.
If the image has no other alpha, the following PE number of 24 bit entries contains the RGB color.

After the palette comes the image bits in BPP sized chunks. If there only transparency, the transparent index equals PE.
